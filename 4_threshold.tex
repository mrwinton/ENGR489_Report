%!TEX root = proj_report_outline.tex
\chapter{Threshold Security Scheme}\label{C:threshholdSecurity}

\section{Design}
As discussed in Section \ref{S:databaseSecurity} Shamir's Secret Sharing Scheme is a threshold security scheme based on Lagrange interpolation. Recall, the scheme works by splitting the secret into \textit{n} shares, \textit{k} of which are required to then retrieve the original secret. In this section the design for the service enabling PitchHub to leverage the secret sharing scheme is discussed.

\subsection{Shamir's Secret Sharing Scheme Service}
First, in designing the service an open-source implementation of Shamir's Secret Sharing was selected. This was a key design decision. While the principles of Shamir's Secret Sharing are simple, personally implementing a cryptography library should be treated with care. To implement and establish trust in such a component would require rigorous testing to be proven as secure. Leveraging the collective strength of the open-source community ensures that the implementations have had many eyes go through them (with different backgrounds/expertises). The primary activity for PitchHub in regards to Secret Sharing was to design and implement a service that integrates the security scheme.
\par
As discussed by prominent cryptographer and author \citeauthor{schneier1999cryptography} ``Building cryptography into products is hard... Flaws can appear anywhere. They can be in the trust model, the system design, the algorithms and protocols, the implementations, the source code, the human-computer interface, the procedures, the underlying computer system. Anywhere.'' \cite{schneier1999cryptography}. PitchHub  approached the integration of the security scheme library with emphasis on limiting the amount of coupling. By reducing coupling between the library and wider system we reduce the risk of system knowledge producing vulnerabilities within PitchHub and undermining the security scheme's integrity.
\par
In designing this service the MVC architecture pattern was analysed in regards to which component is most suitable to handle this responsibility. The model could use a Ruby mixin to override both it's \textit{save} and \textit{find} methods such that the secret was split into \textit{n} shares on \textit{save} for the \textit{n} databases. \textit{Find} would work similarly, merely combining the queried shares from the \textit{k..n} databases and presenting the clear text secret. The view component is not supposed to deal with business logic and hence not an appropriate candidate for this responsibility. The controller in it's capacity of delegating tasks to models could also bear this responsibility. In the controller on \textit{saves} it could split the secret among \textit{n} models and save each model to a distinct database. With \textit{finds} the controller would need to connect to each database and retrieve the requested secrets to combine. The pros and cons of each design is apparent. Going strictly the model route would mean \textit{monkey patching} \cite{Monke1:online} the behaviour of the ODM which could make it hard for other components that do not wish to use the Secret Sharing implementation also this would require that models have knowledge outside of itself. Going strictly controller means that there is a fair amount of business logic within the controllers. However, both approaches consolidate the integration of the Secret Sharing library within it's own component. Ultimately, the final approach was a mixture of the above, controllers were modified such that they use explicit Secret Sharing \textit{find} and \textit{save} methods which encapsulate the knowledge of the \textit{n} secret keeper databases, within these explicit Secret Sharing database methods the logic of the Secret Sharing library is isolated.
\par
Despite both Models and Controllers being aware of the Secret Sharing functionality, they are only aware of as much to the capacity of their roles. The model handles the business logic, while the controller handles the delegation.

\subsection{Overcoming Limitations of Threshold Security Schemes}
Given share combinations up to \textit{k}, Secret Sharing Schemes ensure that the secret is not revealed. However, if an attacker gains \textit{k} secret shares, the secret is easily reconstructed. This is simultaneously the advantage and weakness of Threshold Security Schemes. To explore further: up to \textit{k} compromised databases do not compromise the security of the secrets being held, but is reasonable to suggest that if an attacker can break into one database they are capable of breaking into all of them. Furthermore this scheme relies on the availability of \textit{k} secret keepers, should \textit{k} be unattainable the secrets are rendered irretrievable to both authorised and unauthorised users alike.
\par
In the context of PitchHub were MongoDB was the database of choice, to bring down the service attackers need only be familiar with MongoDB vulnerabilities. This issue is explored in \cite{littlewood2004redundancy}.


\section{Implementation}

\subsection{Shamir's Secret Sharing Scheme Service}

\subsection{Secret Keeper Redundancy}